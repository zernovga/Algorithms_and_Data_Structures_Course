## 1. Найти сложность приведенного ниже соотношения:  

$
T(n) = \begin{cases} 
    3T(n-1), &\text{если } n>0,\\
    1, &\text{иначе} 
\end{cases}
$

Сложность данного рекурсивного соотношения $T(n) = 3T(n-1)$ равна $O(3^n)$.
## 2. Найти сложность приведенного ниже соотношения:  
$
T(n) = \begin{cases} 
    2T(n-1) – 1 &\text{если } n>0,\\
    1, &\text{иначе} 
\end{cases}
$
Сложность данного рекурсивного соотношения $T(n) = 2T(n-1) - 1$ равна экспоненциальной, а именно $O(2^n)$. 

Почему? При каждом увеличении $n$ на 1, мы выполняем два вызова функции $T$ с аргументом $n-1$, и затем вычитаем 1. Это приводит к удвоению числа вызовов на каждом уровне рекурсии. 

Таким образом, уровень глубины рекурсии будет равен $n$, и на каждом уровне увеличивается количество вызовов вдвое. Итоговая сложность $O(2^n)$ отражает экспоненциальное увеличение числа операций с увеличением $n$.
## 3. Найти сложность приведенной ниже программы:

```python
def funct(n):
    if (n==1):
        return
    for i in range(1, n+1):
        for j in range(1, n + 1):
            print("*", end = "")
            break
          print()
```
Сложность данной программы - квадратичная, то есть $O(n^2)$. Это потому, что у нас есть два вложенных цикла: первый цикл идет от 1 до n, а второй тоже идет от 1 до n. Это означает, что общее число итераций составит n * n, что эквивалентно $O(n^2)$ операциям.

## 4. Найти сложность приведенной ниже программы:

```python
def funct(n):
    count = 0
    for i in range(n//2, n+1):
        j = 1
        while j <= n:
            j = 2 * j
            k = 1
            while k <= n:
                k = 2 * k
                count += 1
```
Сложность данной программы - логарифмическая, то есть $O(\log n)$. Это потому, что циклы выполняются до тех пор, пока их счетчики (j и k) не достигнут или превысят значение n. Поскольку j и k удваиваются на каждой итерации, количество итераций в циклах будет логарифмическим по отношению к n. Следовательно, сложность программы оценивается как $O(\log n)$.

## 5. Найти сложность приведенной ниже программы: 

```python
def funct(n):
    count = 0
    for i in range(n//2, n+1):
        j = 1
        while j + n // 2 <= n:
            j += 1
            k = 1
            while k <= n:
                k = 2 * k
                count += 1
```
Сложность данной программы - квадратичная, то есть $O(n^2)$. Это происходит из-за двух вложенных циклов. Внешний цикл выполняется от `n//2` до `n`, что дает примерно `n/2` итераций. Внутренний цикл выполняется до тех пор, пока `k` не станет больше или равным `n`, и каждый раз удваивает значение `k`. Таким образом, общее число итераций составит примерно `(n/2) * n = (n^2)/2`, что эквивалентно $O(n^2)$ операциям.

## 6. Найти сложность приведенной ниже программы: 

```py
def function(n):
    i = 1
    s = 1
    while s <= n:
        i += 1
        s += i
        print('*')
```
Сложность данной программы - линейная, то есть $O(n)$. Программа выполняет цикл, который увеличивает значение `i` и `s` на каждой итерации до тех пор, пока `s` не превысит `n`. Количество итераций будет линейно зависеть от `n`, поэтому сложность программы оценивается как $O(n)$.
## 7. Найти сложность приведенной ниже программы: 

```py
def function(n):
    count = 0
    for i in range(n):
        for j in range(i, i * i):
            if j % i == 0:
                for k in range(j):
                    print('*')
```
Сложность данной программы - кубическая, то есть $O(n^3)$. Программа имеет три вложенных цикла: внешний цикл выполняется `n` раз, следующий цикл в зависимости от `i` будет выполняться от `i` до `i*i` раз, и внутренний цикл, который будет выполняться `j` раз для каждого `j`, где `j` находится в диапазоне от `i` до `i*i`. Общее количество операций будет пропорционально `n^3`, и поэтому сложность программы оценивается как $O(n^3)$.
## 8. Найти сложность приведенной ниже программы: 

```python
def function(n):
    i = 1
    s = 1
    while (s < n):
        s = s + i
        i+=1
``` Сложность данной программы - квадратичная, то есть O(n^2). Программа выполняет цикл, в котором переменные `s` и `i` обновляются с каждой итерацией до тех пор, пока `s` не станет больше или равным `n`. Количество итераций будет примерно квадратичным относительно `n`, поскольку `i` увеличивается с каждой итерацией, и `s` также увеличивается в зависимости от `i`. Следовательно, сложность программы оценивается как O(n^2).

## 9. Найти сложность приведенной ниже программы: 


```python
def fun(n):
    if (n < 5):
        print("Sirius", end ="")
    else:
        for i in range(n):
            print(i, end= " ")
```
Сложность данной программы зависит от значения `n`. Если `n` меньше 5, то программа выполняет постоянное количество операций (в данном случае вывод строки). В этом случае сложность будет $O(1)$, то есть постоянной.

Однако, если `n` больше или равно 5, то программа выполняет цикл, который итерируется `n` раз и выводит значение `i`. В этом случае сложность будет линейной относительно `n`, и равна $O(n)$.

Итак, сложность этой программы может быть $O(1)$ или $O(n)$ в зависимости от значения `n`.
## 10. Найти сложность приведенной ниже программы в лучшем и в худшем случае: 


```python
def fun(a, b):
    while (a != b):
        if (a > b):
            a = a - b
        else:
            b = b - a
```             
Сложность данной программы зависит от значений `a` и `b`.

- В лучшем случае (когда `a` и `b` уже равны), цикл не выполнится ни разу, и программа завершится сразу. В этом случае сложность будет $O(1)$.

- В худшем случае (когда `a` и `b` взаимно просты и не имеют общих делителей, кроме 1), цикл будет выполняться до тех пор, пока `a` и `b` не станут равными. Сложность в худшем случае оценивается как $O(\max(a, b))$.

Таким образом, сложность программы может варьироваться от $O(1)$ до $O(\max(a, b))$ в зависимости от значений `a` и `b`.
## 11. Найти сложность приведенной ниже программы: 

```py
def fun(n):
    i = 0
    while i*i < n:
        print("Sirius")
        i += 1
```
Сложность данной программы - линейная, то есть O(sqrt(n)). Программа выполняет цикл, в котором значение `i` увеличивается до тех пор, пока `i*i` не станет больше или равным `n`. Так как `i` увеличивается на каждой итерации, количество итераций будет примерно равно квадратному корню из `n`, что дает линейную сложность O(sqrt(n)).
## 12. Найти сложность приведенной ниже программы: 

```py
def fun(n, x):
  for i in range(1, n, i * x):
    print("Sirius")
```
В данной программе есть ошибка в коде: переменная `i` не инициализирована перед использованием в цикле. Поэтому я предположу, что вы хотели написать `for i in range(1, n, i * x)`, где `i` начинается с 1.

Если это так, то сложность программы будет линейной, то есть $O(n)$. Это потому, что цикл будет выполняться от 1 до `n` с шагом `i * x`, и количество итераций будет линейно зависеть от `n`, поскольку `i` увеличивается с каждой итерацией.

## 13. Найти сложность приведенной ниже программы: 

```py
import math
 
def fun(n):
    for i in range(0,math.floor(n/2)):
        for j in range(1,n-math.floor(n/2)+1):
            k=1;
            for k in range(1,n+1,2*k):
                 print("Sirius");
```Сложность данной программы - квадратичная, то есть O(n^2). Программа имеет два вложенных цикла: внешний цикл идет от 0 до `n/2`, а внутренний цикл идет от 1 до `n - n/2 + 1`. Внутри внутреннего цикла есть еще один цикл, который идет до `n` с шагом `2*k`. Общее количество операций будет пропорционально `n^2`, и поэтому сложность программы оценивается как O(n^2).

## 14. Найти сложность приведенной ниже программы: 

```python
def fun(n):
    for i in range(1,n+1):
        for j in range(1,n+1,i):
            print("Sirius");

```
Сложность данной программы - квадратичная, то есть O(n^2). Программа имеет два вложенных цикла: внешний цикл идет от 1 до `n`, а внутренний цикл идет от 1 до `n` с шагом `i`. Общее количество операций будет пропорционально `n^2`, и поэтому сложность программы оценивается как O(n^2).
## 15. Найти сложность приведенной ниже программы: 

```py
def fun(n):
    for i in range(n//3 + 1):
        for j in range(1, n+1, 4):
            print("Sirius")
```             
Сложность данной программы - линейная, то есть O(n). Программа имеет два вложенных цикла: внешний цикл идет от 0 до `n//3`, а внутренний цикл идет от 1 до `n` с шагом 4. Общее количество операций будет пропорционально `n`, и поэтому сложность программы оценивается как O(n).
## 16. Найти сложность приведенной ниже программы:  

```py
def fun(n):
    i = 1
    while (i < n):
        j = n
        while (j > 0):
            j = j // 2
        i = i * 2
```
Сложность данной программы - логарифмическая, то есть O(log n). Оба цикла в программе зависят от переменных, которые увеличиваются или уменьшаются в два раза на каждой итерации. Внешний цикл выполняется до тех пор, пока `i` не станет больше или равным `n`, и такое количество итераций можно оценить как log₂(n), что соответствует логарифмической сложности O(log n).
## 17. Найти какое число сравнений будет сделано при выполнении следующего фрагмента кода?  
```py
def fun(n):
    j = 1
    while (j <= n):
        j = j * 2
```
В данном фрагменте кода сравнение выполняется в цикле, где `j` умножается на 2 на каждой итерации, и цикл продолжает выполняться, пока `j` меньше или равно `n`.

Чтобы найти количество сравнений, нужно определить, сколько раз `j` будет умножено на 2, чтобы стать больше `n`. Если `n` - степень двойки (например, 2, 4, 8, 16 и т. д.), то цикл выполнится ровно log₂(n) раз. Если `n` не является степенью двойки, то цикл выполнится до ближайшей меньшей степени двойки и количество сравнений будет log₂(n) + 1.

Таким образом, количество сравнений в данном фрагменте кода будет log₂(n) или log₂(n) + 1, в зависимости от того, является ли `n` степенью двойки или нет.
## 18. Найти сложность приведенной ниже программы: 
 
```py
a = 0
b = 0
for i in range(N):
    a = a + random()
 
for i in range(M):
    b = b + random()
 ```
Сложность данной программы - линейная, то есть O(N + M), где N и M - количество итераций в первом и втором циклах соответственно. Оба цикла выполняют операции, которые зависят от N и M, но каждый из них имеет линейную сложность по отдельности, и общая сложность определяется суммой N и M, что дает O(N + M).
## 19. Найти сложность приведенной ниже программы: 
 
```py
a = 0;
for i in range(N):
    for j in reversed(range(i,N)):
        a = a + i + j;
 ```
Сложность данной программы - квадратичная, то есть O(N^2), где N - количество итераций во внешнем цикле. Программа имеет два вложенных цикла: внешний цикл выполняется N раз, а внутренний цикл также выполняется N раз (но с уменьшением диапазона итераций с каждой итерацией внешнего цикла). Общее количество операций будет пропорционально N^2, что дает квадратичную сложность.
## 20. Найти сложность приведенной ниже программы: 
 
```py
k = 0;
for i in range(n//2,n):
    for j in range(2,n,pow(2,j)):
        k = k + n / 2;
 ```
Сложность данной программы - квадратичная, то есть O(n^2), где n - количество итераций во внешнем цикле. Внешний цикл выполняется от n/2 до n, и внутренний цикл выполняется с шагом, увеличивающимся в геометрической прогрессии (2^j), где j внешнего цикла. Таким образом, общее количество операций будет пропорционально n^2, что дает квадратичную сложность.
## 21. Найти сложность приведенной ниже программы: 
```py
a = 0
i = N
while (i > 0):
    a += i
    i //= 2
``` 
Сложность данной программы - логарифмическая, то есть O(log N), где N - начальное значение переменной `i`. В программе выполняется цикл, в котором `i` уменьшается вдвое с каждой итерацией, и при этом к переменной `a` добавляется значение `i`. Так как количество итераций зависит от количества уменьшений `i` вдвое до достижения 0, то сложность оценивается как логарифмическая относительно N.
## 22. Найти сложность приведенной ниже программы: 

```py
for i in range(n):
    i = i * k
```
Сложность данной программы - линейная, то есть O(n), где n - количество итераций в цикле. Программа выполняет один цикл, в котором значение переменной `i` умножается на `k`. Количество операций в цикле линейно зависит от `n`, и, следовательно, сложность программы оценивается как O(n).
## 23. Найти сложность приведенной ниже программы: 

```py
value = 0
for i in range(n):
    for j in range(i):
        value = value + 1
```Сложность данной программы - квадратичная, то есть O(n^2), где n - количество итераций во внешнем цикле. Программа имеет два вложенных цикла: внешний цикл выполняется n раз, а внутренний цикл идет от 0 до i, где i - текущая итерация внешнего цикла. Общее количество операций будет пропорционально n^2, что дает квадратичную сложность.
