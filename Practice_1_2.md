## 1. Найти сложность приведенного ниже соотношения:

$
T(n) = \begin{cases}
    3T(n-1), &\text{если } n>0,\\
    1, &\text{иначе}
\end{cases}
$

Ans: O(3^n) # рекурсивный перебор значений

## 2. Найти сложность приведенного ниже соотношения:
$
T(n) = \begin{cases}
    2T(n-1) – 1 &\text{если } n>0,\\
    1, &\text{иначе}
\end{cases}
$

Ans: O(1) # рекурсивный перебор значений

## 3. Найти сложность приведенной ниже программы:

```python
def funct(n):
    if (n==1):
        return
    for i in range(1, n+1):
        for j in range(1, n + 1):
            print("*", end = "")
            break
          print()
```

Ans: O(n) # break на каждой первой итерации вложенного цикла


## 4. Найти сложность приведенной ниже программы:

```python
def funct(n):
    count = 0
    for i in range(n//2, n+1):
        j = 1
        while j <= n:
            j = 2 * j
            k = 1
            while k <= n:
                k = 2 * k
                count += 1
```
Ans: O(n * log(n)^2) # 1 O(n) + вложенный O(log(n)) и в него же вложенный O(log(n))

## 5. Найти сложность приведенной ниже программы:

```python
def funct(n):
    count = 0
    for i in range(n//2, n+1):
        j = 1
        while j + n // 2 <= n:
            j += 1
            k = 1
            while k <= n:
                k = 2 * k
                count += 1
```

Ans: O(n^2 * log(n)) # 1 O(n) + вложенный O(n) и в него же вложенный O(log(n))

## 6. Найти сложность приведенной ниже программы:

```py
def function(n):
    i = 1
    s = 1
    while s <= n:
        i += 1
        s += i
        print('*')
```

Ans: O(sqrt(n)) # каждую итерацию суммирование старого значения + 1

## 7. Найти сложность приведенной ниже программы:

```py
def function(n):
    count = 0
    for i in range(n):
        for j in range(i, i * i):
            if j % i == 0:
                for k in range(j):
                    print('*')
```

Ans: O(n^5) # 5 вложенностей O(n)

## 8. Найти сложность приведенной ниже программы:

```python
def function(n):
    i = 1
    s = 1
    while (s < n):
        s = s + i
        i+=1
```

Ans: O(sqrt(n)) # как и в 6, но 1 операция не повлияет на итоговую сложность

## 9. Найти сложность приведенной ниже программы:


```python
def fun(n):
    if (n < 5):
        print("Sirius", end ="")
    else:
        for i in range(n):
            print(i, end= " ")
```

Ans: O(n) # в худшем случае - O(n)

## 10. Найти сложность приведенной ниже программы в лучшем и в худшем случае:


```python
def fun(a, b): # 4, 7
    while (a != b):
        if (a > b):
            a = a - b
        else:
            b = b - a
```

Ans: O(n) # худший случай: b = a - 1 или наоборот

## 11. Найти сложность приведенной ниже программы:

```py
def fun(n):
    i = 0
    while i*i < n:
        print("Sirius")
        i += 1
```

Ans: O(sqrt(n)) # цикл дойдет до i = sqrt(n)
## 12. Найти сложность приведенной ниже программы:

```py
def fun(n, x):
  for i in range(1, n, i * x):
    print("Sirius")
```

Ans: O(~) (infinity) # т.к шаг = 0, то будет бесконечное кол-во итераций

## 13. Найти сложность приведенной ниже программы:

```py
import math

def fun(n):
    for i in range(0,math.floor(n/2)):
        for j in range(1,n-math.floor(n/2)+1):
            k=1;
            for k in range(1,n+1,2*k):
                 print("Sirius");
```

Ans: O(n^3) # операции, проделанные с переменной n не повлияют на итоговую сложность

## 14. Найти сложность приведенной ниже программы:

```python
def fun(n):
    for i in range(1,n+1):
        for j in range(1,n+1,i):
            print("Sirius");

```

Ans: O(n * sqrt(n)) # обычный цикл до n с шагом 1 + цикл c шагом, увеличиваюшимся на каждой итерации

## 15. Найти сложность приведенной ниже программы:

```py
def fun(n):
    for i in range(n//3 + 1):
        for j in range(1, n+1, 4):
            print("Sirius")
```

Ans: O(n^2) # операции, проделанные с переменной n не повлияют на итоговую сложность

## 16. Найти сложность приведенной ниже программы:

```py
def fun(n):
    i = 1
    while (i < n):
        j = n
        while (j > 0):
            j = j // 2
        i = i * 2
```

Ans: O(log(n) ^ 2) # log(n) + вложенный в него log(n)

## 17. Найти какое число сравнений будет сделано при выполнении следующего фрагмента кода?
```py
def fun(n):
    j = 1
    while (j <= n):
        j = j * 2
```

Ans: O(log(n)) # переменная j на каждой итерации увеличивается вдвое, это логарифмическая сложность

## 18. Найти сложность приведенной ниже программы:

```py
a = 0
b = 0
for i in range(N):
    a = a + random()

for i in range(M):
    b = b + random()
 ```

Ans: O(n + m)) # логично, будет n + m операций

## 19. Найти сложность приведенной ниже программы:

```py
a = 0;
for i in range(N):
    for j in reversed(range(i,N)):
        a = a + i + j;
 ```

Ans: O(n^2) # от реверса ничего не измекнится

## 20. Найти сложность приведенной ниже программы:

```py
k = 0;
for i in range(n//2,n):
    for j in range(2,n,pow(2,j)):
        k = k + n / 2;
 ```

Ans: O(n * log(n)) # т.к в шаге функция pow, возводящая текущую переменную итерацию в степень двойки, то во вложенном цикле будет лог. комплексити

## 21. Найти сложность приведенной ниже программы:
```py
a = 0
i = N
while (i > 0):
    a += i
    i //= 2
```

Ans: O(log(n)) # i каждую итерацию уменьшается вдвое

## 22. Найти сложность приведенной ниже программы:

```py
for i in range(n):
    i = i * k
```

Ans: O(log(n)) (по основанию k) # i каждый раз увеличивается в k раз => log`k(n)


## 23. Найти сложность приведенной ниже программы:

```py
value = 0
for i in range(n):
    for j in range(i):
        value = value + 1
```

Ans: O(n * sqrt(n)) # тоже самое, что и в предыдущих заданиях с такой же сложностью, но тут сначала будет меньше итераций во вложенном цикле
